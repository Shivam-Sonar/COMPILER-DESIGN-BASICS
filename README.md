# COMPILER-DESIGN-BASICS
*COMPANY NAME*:- CODTECH IT SOLUTIONS
*NAME*:- Sonar Shivam Suryanath
*INTERN ID*:- CT04DH2913
*DOMAIN*:- C++ Programming
*DURATION* :- 4 WEEKS
*MENTOR* :- Neela Santhosh Kumar
Description:-
This C++ program is a simple compiler/interpreter that evaluates arithmetic expressions provided by the user. It supports basic mathematical operations like addition, subtraction, multiplication, division, and parentheses for grouping. The code demonstrates fundamental concepts of compiler design: lexical analysis, parsing, and evaluation.
# Token & TokenType
At the core of the lexical analyzer is the Token structure and TokenType enumeration.
TokenType defines the different kinds of tokens the lexer can produce: numbers, operators (+, -, *, /), parentheses, and an End token indicating the end of input.Token holds a type and optionally a value (used only for numbers).This separation allows the parser to understand and handle different parts of the input expression appropriately.
# Lexer (Lexical Analyzer)
The Lexer class reads the user's input and converts the raw string into tokens (also known as lexemes). This process is known as tokenization.
It skips over whitespace.
It recognizes numeric literals (integers) and converts them into TokenType::Number.
It matches individual characters to operators or parentheses, returning the corresponding tokens.
If it encounters an invalid character, it throws an exception.
This is the first step in compiling or interpreting any expression: breaking down the raw input into meaningful symbols.
# Parser (Recursive Descent Parser)
The Parser class processes the token stream generated by the lexer. It implements a recursive descent parser, a top-down parsing technique that uses recursive functions to process expressions based on a grammar.
The parsing follows this grammar hierarchy:
go
Copy
Edit
expression ::= term
term       ::= add_sub
add_sub    ::= mul_div { (+|-) mul_div }
mul_div    ::= factor { (*|/) factor }
factor     ::= number | (expression) | -factor
Here’s a breakdown of the parser’s responsibilities:
parseExpression(): The entry point; it delegates to parseTerm().
parseTerm(): Just calls parseAddSub() (a naming artifact, can be improved).
parseAddSub(): Handles + and - operations with left-to-right associativity.
parseMulDiv(): Handles * and / operations, also left-to-right.
parseFactor():
Returns numbers as-is.
Supports parentheses by recursively evaluating expressions within them.
Handles unary minus (e.g., -5).
The parser evaluates expressions on the fly (interpretation) rather than building an abstract syntax tree (AST), which makes it faster and simpler for basic use cases.
#Main Function
The main() function serves as the user interface:
Prompts the user to enter arithmetic expressions.
Passes input to the lexer and parser.
Catches and displays any runtime errors (such as invalid input or division by zero).
#Error Handling
The program provides basic but useful error messages:
Invalid characters are reported with descriptive errors.
Unexpected tokens during parsing throw exceptions.
Division by zero is checked and handled explicitly.
These checks make the program more robust and user-friendly.
Allows repeated evaluation until the user types "exit".
This loop creates a simple Read-Eval-Print Loop (REPL), which is common in interpreters.

#Output
<img width="813" height="664" alt="Image" src="https://github.com/user-attachments/assets/a5e848ad-f4b4-490f-bd08-639165d9b271" />
